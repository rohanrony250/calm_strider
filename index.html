<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mobile Sensor Logger</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; background:#0b1320; color:#e9eef6; }
    header { padding: 16px 20px; background: #111a2e; box-shadow: 0 2px 10px rgba(0,0,0,.2); position: sticky; top: 0; z-index: 10; }
    h1 { margin: 0; font-size: 18px; letter-spacing:.3px; }
    main { padding: 20px; max-width: 980px; margin: 0 auto; }
    .card { background:#121a33; border:1px solid #1f2a4a; border-radius: 16px; padding: 16px; margin-bottom: 16px; box-shadow: 0 6px 24px rgba(0,0,0,.25); }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items: center; }
    button, select, input[type="number"] { appearance:none; border:1px solid #2b3c67; background:#1a2550; color:#e9eef6; padding: 10px 14px; border-radius: 12px; font-weight:600; }
    button { cursor:pointer; }
    button[disabled] { opacity:.6; cursor:not-allowed; }
    .stat { min-width: 140px; background:#0f1730; border:1px solid #1f2a4a; padding:10px 12px; border-radius:12px; text-align:left; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 12px; opacity:.8; }
    .log { max-height: 240px; overflow: auto; background:#0f1730; border:1px solid #1f2a4a; padding:10px; border-radius: 12px; }
    .ok { color:#6df0a8 }
    .warn { color:#ffd580 }
    .err { color:#ff8797 }
    label.l { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2b3c67; border-radius:10px; background:#0f1730; }
  </style>
</head>

<!-- Firebase module: NO AUTH, writes to /public/... + weather cache -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
  import { getDatabase, ref, push, update, set } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB0yzdcWJxsO3dtqWlTJyEjupV8_mdzm0E",
    authDomain: "urban-app-be1f9.firebaseapp.com",
    databaseURL: "https://urban-app-be1f9-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "urban-app-be1f9",
    appId: "1:297008657169:web:e9a9aadf8332b71a6392b0"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);
  console.log("[cloud] Firebase initialized â†’", firebaseConfig.databaseURL);

  // ---- Batch uploader (no auth) ----
  let sessionId = null;
  let buffer = [];
  let flushTimer = null;
  const BUFFER_MAX = 50;
  const FLUSH_MS = 1000;

  function startSession(meta) {
    sessionId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Date.now());
    set(ref(db, `public/sessions/${sessionId}/meta`), { ...meta, startedAt: Date.now(), sdk: "web-rtdb-noauth" })
      .then(() => console.log(`[cloud] session started: public/sessions/${sessionId}`))
      .catch(e => console.warn("[cloud] meta write warn:", e?.message));
    if (flushTimer) clearInterval(flushTimer);
    flushTimer = setInterval(flushBuffer, FLUSH_MS);
    window.log?.(`[cloud] session: public/sessions/${sessionId}`, 'ok');
  }

  async function flushBuffer() {
    if (!sessionId || buffer.length === 0) return;
    const updates = {};
    for (const row of buffer) {
      const key = push(ref(db, `public/sessions/${sessionId}/readings`)).key;
      updates[`public/sessions/${sessionId}/readings/${key}`] = row;
    }
    const count = buffer.length;
    buffer = [];
    try {
      await update(ref(db), updates);
      console.log(`[cloud] uploaded ${count} row(s) â†’ public/sessions/${sessionId}`);
      window.log?.(`[cloud] uploaded ${count} row(s)`, 'ok');
    } catch (e) {
      console.error('[cloud] upload error:', e);
      window.log?.(`[cloud] upload error: ${e.message}`, 'err');
    }
  }

  function stopSession(){
    if (flushTimer) clearInterval(flushTimer), flushTimer=null;
    flushBuffer().then(() => {
      console.log('[cloud] final flush OK for session', sessionId);
      window.log?.('[cloud] final flush OK', 'ok');
    });
  }

  function onSample(row){
    buffer.push(row);
    if (buffer.length >= BUFFER_MAX) flushBuffer();
  }

  window.firebaseUpload = { startSession, onSample, stopSession };

  // ---- Weather ingest â†’ /open/weather + cache latest for rows ----
  let weatherTimer = null;
  let lastWeather = null; // cached snapshot

  function tile(lat, lon, step=0.01){ const r=v => (Math.round(v/step)*step).toFixed(2); return `${r(lat)}_${r(lon)}`; }

  async function writeWeather(lat, lon){
    try {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,wind_speed_10m,precipitation`;
      const j = await fetch(url).then(r=>r.json());
      const cur = j.current || j.current_weather || {};

      const t = Date.now();
      lastWeather = {
        ts: t,
        source: "open-meteo",
        temp_c: cur.temperature_2m ?? cur.temperature ?? null,
        wind_mps: cur.wind_speed_10m ?? (typeof cur.windspeed === "number" ? cur.windspeed/3.6 : null),
        precip_mm: cur.precipitation ?? null
      };
      window.__lastWeather = lastWeather; // expose to logger

      const til = tile(lat, lon);
      await set(ref(db, `open/weather/${til}/${t}`), { lat, lon, current: lastWeather, fetched_at: t });

      console.log(`[cloud] weather write @ ${til}/${t}`, lastWeather);
      window.log?.(`[cloud] weather @ ${til}`, 'ok');
    } catch(e){
      console.error("[cloud] weather ingest", e);
      window.log?.(`[cloud] weather error: ${e.message}`, 'err');
    }
  }

  function startWeatherIngest(getLatLonFn){
    if (weatherTimer) clearInterval(weatherTimer);
    const tick = async () => {
      const p = getLatLonFn?.();
      if (p && p.lat != null && p.lon != null) await writeWeather(p.lat, p.lon);
    };
    tick();                                  // fetch immediately
    weatherTimer = setInterval(tick, 60_000);// then every 60s
    console.log("[cloud] weather ingest started");
  }
  function stopWeatherIngest(){ if (weatherTimer) clearInterval(weatherTimer), weatherTimer=null; console.log("[cloud] weather ingest stopped"); }
  function fetchNow(lat, lon){ return writeWeather(lat, lon); }

  window.weatherIngest = { startWeatherIngest, stopWeatherIngest, fetchNow };
  console.log("[cloud] uploader ready (no-auth)");
</script>

<body>
  <header>
    <h1>ðŸ“± Mobile Sensor Logger â€” Accelerometer + GPS + (opt) Mic</h1>
  </header>
  <main>
    <div class="card">
      <p>Record accelerometer, GPS and optional microphone <em>loudness</em> (no audio saved). Exports a CSV locallyâ€”no server needed.</p>
      <p class="small">Columns: timestamp_iso, timestamp_ms, lat, lon, accuracy_m, altitude_m, speed_mps, heading_deg, ax, ay, az, a_total, rot_alpha_dps, rot_beta_dps, rot_gamma_dps, <strong>dbfs, db_smooth, mic_active, tag</strong>, sample_id, <strong>w_temp_c, w_wind_mps, w_precip_mm, w_ts, w_source</strong></p>
    </div>

    <div class="card">
      <div class="row" style="gap:8px; margin-bottom:12px;">
        <button id="permBtn">Request Permissions</button>
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="downloadBtn" disabled>Download CSV</button>
        <button id="startMicBtn">Start Mic</button>
        <button id="stopMicBtn" disabled>Stop Mic</button>
        <button id="tagBtn">Tag</button>
        <label class="l small">Mode
          <select id="modeSel" class="mono">
            <option value="throttle" selected>Event-throttle</option>
            <option value="timer">Fixed-interval</option>
          </select>
        </label>
        <label class="l small">Rate
          <select id="rateSel" class="mono">
            <option value="0.5">0.5 Hz</option>
            <option value="1">1 Hz</option>
            <option value="2">2 Hz</option>
            <option value="5">5 Hz</option>
            <option value="10">10 Hz</option>
            <option value="20" selected>20 Hz</option>
            <option value="50">50 Hz</option>
            <option value="60">60 Hz</option>
            <option value="raw">raw</option>
          </select>
        </label>
      </div>
      <div class="row">
        <div class="stat"><div class="small">Samples</div><div class="mono" id="samples">0</div></div>
        <div class="stat"><div class="small">GPS Fix</div><div class="mono" id="gps">â€”</div></div>
        <div class="stat"><div class="small">Speed (m/s)</div><div class="mono" id="speed">â€”</div></div>
        <div class="stat"><div class="small">Accel |a| (m/sÂ²)</div><div class="mono" id="amag">â€”</div></div>
        <div class="stat"><div class="small">Noise (dBFS)</div><div class="mono" id="db">â€”</div></div>
        <div class="stat"><div class="small">Mic</div><div class="mono" id="mic">off</div></div>
        <div class="stat"><div class="small">Tags</div><div class="mono" id="tags">0</div></div>
      </div>
    </div>

    <div class="card">
      <div class="small">Status</div>
      <pre class="log mono" id="log"></pre>
    </div>
  </main>

<script>
(function(){
  const permBtn = document.getElementById('permBtn');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const samplesEl = document.getElementById('samples');
  const gpsEl = document.getElementById('gps');
  const speedEl = document.getElementById('speed');
  const amagEl = document.getElementById('amag');
  const dbEl = document.getElementById('db');
  const micEl = document.getElementById('mic');
  const tagsEl = document.getElementById('tags');
  const logEl = document.getElementById('log');
  const rateSel = document.getElementById('rateSel');
  const modeSel = document.getElementById('modeSel');

  let recording = false;
  let watchId = null;
  let latestGeo = null;
  let data = [];
  let sampleId = 0;

  // motion snapshot
  let lastAx = null, lastAy = null, lastAz = null, lastAmag = null;
  let motionHandler = null;

  // audio state
  let audioCtx = null, analyser = null, micStream = null, micRaf = null;
  let micActive = false;
  let lastDbfs = null, lastDbSmooth = null;

  let tags = [];
  let lastTag = null;

  // sampling control
  let writeMode = 'throttle';
  let minIntervalMs = 50;
  let timerId = null;
  let intervalMs = 50;
  let lastWriteTs = 0;

  const log = (msg, cls='') => {
    const line = document.createElement('div');
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    if (cls) line.className = cls;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  };
  window.log = log; // let the Firebase module write into our Status box

  function hasMotionSupport(){ return 'DeviceMotionEvent' in window; }
  function hasGeoSupport(){ return 'geolocation' in navigator; }

  async function requestPermissions(){
    try {
      if (!hasMotionSupport()) {
        log('DeviceMotion not supported on this device.', 'err');
      } else if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const resp = await DeviceMotionEvent.requestPermission();
        log(`Motion permission: ${resp}`, resp === 'granted' ? 'ok' : 'err');
      } else {
        log('Motion permission: not required on this device', 'ok');
      }

      if (hasGeoSupport()) {
        await new Promise((resolve) => {
          navigator.geolocation.getCurrentPosition(
            (pos) => { latestGeo = pos; log('Location permission granted', 'ok'); resolve(); },
            (err) => { log('Location permission error: ' + err.message, 'err'); resolve(); },
            { enableHighAccuracy: true, timeout: 7000, maximumAge: 0 }
          );
        });
      } else { log('Geolocation not supported on this device.', 'err'); }
    } catch (e) { log('Permission request error: ' + e.message, 'err'); }
  }

  // --- CSV builder ---
  function buildCSV(headers, rows){
    const esc = (v) => {
      if (v == null) return '';
      const s = String(v);
      const needsQuotes = /[",\n\r]/.test(s);
      const q = s.replace(/"/g, '""');
      return needsQuotes ? '"' + q + '"' : q;
    };
    let out = headers.join(',') + '\n';
    for (const row of rows){ out += headers.map(h => esc(row[h])).join(',') + '\n'; }
    return out;
  }

  function makeRow(now){
    const g = latestGeo ? latestGeo.coords : {};
    const w = window.__lastWeather || null;  // <-- latest weather snapshot
    const r = { alpha: null, beta: null, gamma: null };
    return {
      timestamp_iso: new Date(now).toISOString(),
      timestamp_ms: now,
      lat: g.latitude ?? null,
      lon: g.longitude ?? null,
      accuracy_m: g.accuracy ?? null,
      altitude_m: g.altitude ?? null,
      speed_mps: g.speed ?? null,
      heading_deg: g.heading ?? null,
      ax: lastAx, ay: lastAy, az: lastAz,
      a_total: lastAmag,
      rot_alpha_dps: r.alpha ?? null,
      rot_beta_dps: r.beta ?? null,
      rot_gamma_dps: r.gamma ?? null,
      dbfs: lastDbfs,
      db_smooth: lastDbSmooth,
      mic_active: micActive ? 1 : 0,
      tag: lastTag,
      sample_id: sampleId++,

      // --- Weather at sample time ---
      w_temp_c:    w?.temp_c ?? null,
      w_wind_mps:  w?.wind_mps ?? null,
      w_precip_mm: w?.precip_mm ?? null,
      w_ts:        w?.ts ?? null,
      w_source:    w?.source ?? null
    };
  }

  function pushRow(now){
    const row = makeRow(now);
    data.push(row);
    samplesEl.textContent = String(data.length);
    window.firebaseUpload?.onSample(row); // stream to Firebase
    if (lastTag) lastTag = null;
  }

  function start(){
    if (recording) return;
    data = [];
    sampleId = 0;
    lastWriteTs = 0;
    recording = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    downloadBtn.disabled = true;
    log('Recording started', 'ok');

    // start cloud + weather ingest
    window.firebaseUpload?.startSession({ mode: writeMode, rate: rateSel.value, mic: micActive ? 1 : 0 });
    window.weatherIngest?.startWeatherIngest(() => {
      const c = latestGeo?.coords;
      return c ? { lat: c.latitude, lon: c.longitude } : null;
    });

    // GPS
    if (hasGeoSupport()) {
      watchId = navigator.geolocation.watchPosition((pos) => {
        latestGeo = pos;
        const s = pos.coords.speed;
        gpsEl.textContent = `${pos.coords.latitude?.toFixed?.(5) ?? 'â€”'}, ${pos.coords.longitude?.toFixed?.(5) ?? 'â€”'} Â±${(pos.coords.accuracy||0).toFixed(0)}m`;
        speedEl.textContent = (s!=null? s.toFixed(2): 'â€”');

        // kick weather immediately on first/each fix
        window.weatherIngest?.fetchNow(pos.coords.latitude, pos.coords.longitude);
      }, (err) => {
        log('GPS error: ' + err.message, 'warn');
      }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 });
    }

    // Motion
    motionHandler = (ev) => {
      const aIncG = ev.accelerationIncludingGravity || ev.acceleration || {};
      lastAx = aIncG.x ?? null; lastAy = aIncG.y ?? null; lastAz = aIncG.z ?? null;
      lastAmag = (lastAx!=null && lastAy!=null && lastAz!=null) ? Math.sqrt(lastAx*lastAx + lastAy*lastAy + lastAz*lastAz) : null;
      amagEl.textContent = (lastAmag!=null) ? lastAmag.toFixed(2) : 'â€”';

      if (writeMode === 'throttle'){
        const now = Date.now();
        if (minIntervalMs && (now - lastWriteTs) < minIntervalMs) return;
        lastWriteTs = now;
        pushRow(now);
      }
    };
    window.addEventListener('devicemotion', motionHandler, { passive: true });

    // Timer mode
    if (writeMode === 'timer'){
      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => { pushRow(Date.now()); }, intervalMs);
      log(`Fixed-interval mode @ ${Math.round(1000/intervalMs)} Hz`, 'ok');
    }

    setTimeout(() => {
      if (recording && data.length === 0) log('No samples yet. On iOS, tap "Request Permissions" and move the phone slightly.', 'warn');
    }, 5000);
  }

  function stop(){
    if (!recording) return;
    recording = false;

    window.firebaseUpload?.stopSession();          // end cloud session
    window.weatherIngest?.stopWeatherIngest?.();   // stop weather

    startBtn.disabled = false;
    stopBtn.disabled = true;
    downloadBtn.disabled = data.length === 0;

    if (watchId != null) { navigator.geolocation.clearWatch(watchId); watchId = null; }
    if (motionHandler) { window.removeEventListener('devicemotion', motionHandler); motionHandler = null; }
    if (timerId) { clearInterval(timerId); timerId = null; }

    log(`Recording stopped. ${data.length} samples captured.`, 'ok');
  }

  function downloadCSV(){
    if (!data.length) { log('Nothing to download', 'warn'); return; }
    const headers = [
      'timestamp_iso','timestamp_ms','lat','lon','accuracy_m','altitude_m','speed_mps','heading_deg',
      'ax','ay','az','a_total','rot_alpha_dps','rot_beta_dps','rot_gamma_dps',
      'dbfs','db_smooth','mic_active','tag','sample_id',
      // weather fields:
      'w_temp_c','w_wind_mps','w_precip_mm','w_ts','w_source'
    ];
    const csv = buildCSV(headers, data);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const ts = new Date().toISOString().replaceAll(':','-');
    a.download = `sensor_log_${ts}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
    log('CSV downloaded', 'ok');
  }

  // Mic helpers (unchanged)
  async function startMic(){
    try{
      if (micActive) return;
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        log('Mic not supported on this browser.', 'err'); return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      micStream = stream;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') await audioCtx.resume();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      const src = audioCtx.createMediaStreamSource(stream);
      src.connect(analyser);
      micActive = true;
      document.getElementById('startMicBtn').disabled = true;
      document.getElementById('stopMicBtn').disabled = false;
      micEl.textContent = 'on';

      const buf = new Float32Array(analyser.fftSize);
      const alpha = 0.2;
      const update = () => {
        if (!micActive) return;
        analyser.getFloatTimeDomainData(buf);
        let sum = 0; for (let i=0;i<buf.length;i++){ const v=buf[i]; sum += v*v; }
        const rms = Math.sqrt(sum / buf.length) + 1e-12;
        lastDbfs = 20 * Math.log10(rms);
        lastDbSmooth = (lastDbSmooth==null) ? lastDbfs : (alpha*lastDbfs + (1-alpha)*lastDbSmooth);
        dbEl.textContent = lastDbSmooth.toFixed(1);
        micRaf = requestAnimationFrame(update);
      };
      update();
      log('Mic started (dBFS, relative; no audio stored).', 'ok');
    }catch(e){ log('Mic error: ' + e.message, 'err'); }
  }
  function stopMic(){
    if (!micActive) return;
    micActive = false;
    if (micRaf) cancelAnimationFrame(micRaf), micRaf = null;
    if (micStream) { micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
    if (audioCtx) { audioCtx.close(); audioCtx=null; }
    analyser=null; lastDbfs=null;
    document.getElementById('startMicBtn').disabled = false;
    document.getElementById('stopMicBtn').disabled = true;
    micEl.textContent = 'off';
    log('Mic stopped', 'ok');
  }

  // Tag helper
  function addTag(){
    const label = prompt('Tag label (e.g., obstruction, ramp, noise, note:...)');
    if (!label) return;
    tags.push({ ts: Date.now(), label });
    lastTag = label;
    tagsEl.textContent = String(tags.length);
    log('Tagged: ' + label, 'ok');
  }

  // Tests
  function runSelfTests(){
    (function(){ const H=['a','b']; const R=[{a:1,b:2}]; const csv=buildCSV(H,R); const lines=csv.split('\n'); const ok=lines.length>=2&&lines[0]==='a,b'&&lines[1].startsWith('1,2'); log('[test] CSV newline construction', ok?'ok':'err'); })();
    (function(){ const H=['x']; const R=[{x:'he said, "hi"'}]; const csv=buildCSV(H,R); const ok=csv.includes('"he said, ""hi"""'); log('[test] CSV quoting commas/quotes', ok?'ok':'err'); })();
    (function(){ const H=['y']; const R=[{y:'line1\nline2'}]; const csv=buildCSV(H,R); const ok=csv.includes('"line1\nline2"'); log('[test] CSV quoting newlines', ok?'ok':'err'); })();
  }

  // UI
  permBtn.addEventListener('click', requestPermissions);
  startBtn.addEventListener('click', start);
  stopBtn.addEventListener('click', stop);
  downloadBtn.addEventListener('click', downloadCSV);
  document.getElementById('startMicBtn').addEventListener('click', startMic);
  document.getElementById('stopMicBtn').addEventListener('click', stopMic);
  document.getElementById('tagBtn').addEventListener('click', addTag);
  modeSel.addEventListener('change', () => { writeMode = modeSel.value; const v = rateSel.value; applyRate(v); log(`Mode set to: ${writeMode}`, 'ok'); });
  rateSel.addEventListener('change', () => applyRate(rateSel.value));

  function applyRate(v){
    if (v === 'raw'){ minIntervalMs = 0; intervalMs = 0; log('Rate: raw (no throttle)', 'ok'); return; }
    const hz = parseFloat(v); const ms = Math.max(1, Math.round(1000 / hz));
    if (writeMode === 'throttle'){ minIntervalMs = ms; log(`Throttle: ~${hz} Hz (${ms} ms)`, 'ok'); }
    else { intervalMs = ms; if (timerId){ clearInterval(timerId); timerId = setInterval(()=>{ if(recording) pushRow(Date.now()); }, intervalMs);} log(`Fixed-interval: ${hz} Hz (${ms} ms)`, 'ok'); }
  }

  applyRate(rateSel.value);
  if (!hasMotionSupport()) log('This browser does not support DeviceMotion API. Try a modern mobile browser.', 'err');
  if (!hasGeoSupport()) log('Geolocation not available.', 'warn');
  runSelfTests();
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Calm Strider â€” Viewer</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  :root{
    --bg:#0b1320; --card:#121a33; --ink:#e9eef6; --mut:#a8b3cf; --line:#1f2a4a;
    --accent:#5bc0ff; --ok:#6df0a8; --warn:#ffd580; --err:#ff8797;
  }
  *{box-sizing:border-box}
  body{
    margin:0;background:var(--bg);color:var(--ink);
    font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  }
  header{
    position:sticky;top:0;z-index:20;
    background:#111a2e;padding:10px 14px;
    box-shadow:0 2px 12px rgba(0,0,0,.35);
    display:flex;gap:10px;align-items:center;justify-content:space-between;
  }
  h1{font-size:17px;margin:0;font-weight:700}
  .sub{font-size:12px;color:var(--mut)}
  main{max-width:1200px;margin:0 auto;padding:14px}
  .card{
    background:var(--card);border:1px solid var(--line);
    border-radius:14px;padding:12px;margin-bottom:14px;
  }
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  select,button,input[type="range"]{
    appearance:none;background:#1a2550;border:1px solid #2b3c67;color:var(--ink);
    padding:6px 10px;border-radius:10px;font-weight:600;cursor:pointer;font-size:13px;
  }
  button[disabled]{opacity:.6;cursor:not-allowed}
  .pill{
    display:inline-flex;align-items:center;gap:6px;
    padding:6px 10px;border-radius:999px;
    border:1px solid var(--line);background:#0f1730;font-size:12px;
  }
  .statgrid{
    display:grid;grid-template-columns:repeat(7,minmax(110px,1fr));gap:10px;
  }
  .stat{
    background:#0f1730;border:1px solid var(--line);
    border-radius:10px;padding:8px 10px;
  }
  .k{font-size:11px;color:var(--mut)}
  .v{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:16px}
  .badge{
    display:inline-block;font-size:11px;
    padding:1px 8px;border-radius:999px;border:1px solid var(--line);
  }
  .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
  #map{height:420px;border-radius:12px}
  canvas{
    background:#0f1730;border-radius:12px;border:1px solid var(--line);
  }
  .tabs{display:flex;gap:8px;margin:10px 0}
  .tab{
    padding:8px 12px;border:1px solid var(--line);
    border-radius:10px;background:#0f1730;cursor:pointer;font-weight:600;
  }
  .tab.active{outline:2px solid #2b3c67}
  .section{display:none}
  .section.active{display:block}
  .row{display:grid;grid-template-columns:1.2fr .8fr;gap:14px}
  .log{
    max-height:220px;overflow:auto;
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    background:#0f1730;border:1px solid var(--line);
    border-radius:12px;padding:8px;font-size:12px;
  }
  .hint{font-size:12px;color:var(--mut)}
  .flex{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .right{margin-left:auto}
  .weights{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
  .weights .pill{flex:1 1 180px}
  .weights label{font-size:11px;white-space:nowrap}
  .weights span.val{font-size:11px}
  input[type="range"]{width:90px;background:transparent}

  /* Table styles for route comparison */
  table{border-collapse:collapse;width:100%;font-size:12px}
  th,td{padding:4px 6px;border-bottom:1px solid var(--line)}
  th{text-align:left;color:var(--mut);font-weight:600}
  td.num{text-align:right}
  tr.clickable{cursor:pointer}
  tr.clickable:hover{background:#151f3a}

  @media(max-width:1020px){
    .row{grid-template-columns:1fr}
    .statgrid{grid-template-columns:repeat(3,1fr)}
    #map{height:360px}
  }
</style>
</head>
<body>
<header>
  <div>
    <h1>ðŸ“Š Calm Strider â€” Viewer</h1>
    <div class="sub">Inspect logged walks: map, charts, and comfort score from Firebase</div>
  </div>
  <div class="flex">
    <button id="shareBtn">Share</button>
  </div>
</header>

<main>
  <div class="card">
    <div class="controls">
      <strong>Session:</strong>
      <select id="sessionSel"></select>
      <button id="listenBtn">Listen</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="recenterBtn" disabled>Recenter map</button>
      <span class="pill">Auto-follow <input id="followChk" type="checkbox" checked/></span>
      <span class="pill">Accuracy max:
        <span id="accVal">150</span> m
        <input id="accRange" type="range" min="10" max="300" value="150" step="5" />
      </span>
      <span id="status" class="hint right"></span>
    </div>
  </div>

  <div class="card">
    <div class="statgrid">
      <div class="stat"><div class="k">Samples</div><div class="v" id="sCount">0</div></div>
      <div class="stat">
        <div class="k">Comfort</div>
        <div class="v">
          <span id="comfort">â€”</span>
          <span id="comfortBadge" class="badge">â€”</span>
        </div>
        <div class="hint" id="comfortBreak"></div>
      </div>
      <div class="stat"><div class="k">Speed m/s</div><div class="v" id="spd">â€”</div></div>
      <div class="stat"><div class="k">Accel |a|</div><div class="v" id="amag">â€”</div></div>
      <div class="stat">
        <div class="k">Noise dBFS</div>
        <div class="v" id="noise">â€”</div>
        <div class="hint" id="noiseHint"></div>
      </div>
      <div class="stat"><div class="k">Temp Â°C</div><div class="v" id="temp">â€”</div></div>
      <div class="stat">
        <div class="k">Wind m/s Â· Rain mm/h</div>
        <div class="v"><span id="wind">â€”</span> Â· <span id="rain">â€”</span></div>
      </div>
    </div>

    <!-- Weight sliders (retroactive) -->
    <div class="weights">
      <span class="pill">
        <label for="wRough">Roughness</label>
        <input id="wRough" type="range" min="0" max="2" step="0.1" value="1">
        <span class="val" id="wRoughVal">1.0</span>
      </span>
      <span class="pill">
        <label for="wNoise">Noise</label>
        <input id="wNoise" type="range" min="0" max="2" step="0.1" value="1">
        <span class="val" id="wNoiseVal">1.0</span>
      </span>
      <span class="pill">
        <label for="wRain">Rain</label>
        <input id="wRain" type="range" min="0" max="2" step="0.1" value="1">
        <span class="val" id="wRainVal">1.0</span>
      </span>
      <span class="pill">
        <label for="wWind">Wind</label>
        <input id="wWind" type="range" min="0" max="2" step="0.1" value="1">
        <span class="val" id="wWindVal">1.0</span>
      </span>
    </div>
    <div class="hint" style="margin-top:6px;">
      Comfort = 100 â€“ weighted penalties for roughness, noise, rain, and wind. Changing weights recomputes comfort for the whole session.
    </div>
  </div>

  <!-- Route comparison table -->
  <div class="card">
    <div class="k">Route comparison (all sessions)</div>
    <div class="hint">
      Each row is one recorded walk. Routes are sorted by average comfort using analysis stored in Firebase.
      Click a row to open it.
    </div>
    <table style="margin-top:6px;">
      <thead>
        <tr>
          <th>Route</th>
          <th class="num">Avg comfort</th>
          <th class="num">Good / OK / Low</th>
          <th class="num">Samples</th>
        </tr>
      </thead>
      <tbody id="routeTableBody">
        <tr><td colspan="4" style="padding:4px 6px;color:var(--mut);">Loadingâ€¦</td></tr>
      </tbody>
    </table>
  </div>

  <div class="tabs">
    <div class="tab active" data-tab="map">Map</div>
    <div class="tab" data-tab="charts">Charts</div>
    <div class="tab" data-tab="log">Log</div>
  </div>

  <div class="row section active" id="sec-map">
    <div class="card"><div id="map"></div></div>
    <div class="card">
      <div class="k">Last point</div><div class="v" id="lastPoint">â€”</div>
      <div style="height:10px"></div>
      <div class="k">Session meta</div><div class="v" id="sessMeta">â€”</div>
      <div style="height:10px"></div>
      <div class="k">Session analysis</div><div class="v" id="sessAnalysis">â€”</div>
      <div style="height:10px"></div>
      <div class="k">Skipped (accuracy)</div><div class="v" id="skipAcc">0</div>
      <div class="k">Skipped (invalid coords)</div><div class="v" id="skipBad">0</div>
    </div>
  </div>

  <div class="row section" id="sec-charts">
    <div class="card"><canvas id="chartAccel" height="200"></canvas></div>
    <div class="card"><canvas id="chartNoise" height="200"></canvas></div>
  </div>

  <div class="section" id="sec-log">
    <div class="card">
      <div class="k">Event log</div>
      <pre id="log" class="log"></pre>
    </div>
  </div>
</main>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
  import {
    getDatabase, ref, child, get,
    onChildAdded, off, set
  } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB0yzdcWJxsO3dtqWlTJyEjupV8_mdzm0E",
    authDomain: "urban-app-be1f9.firebaseapp.com",
    databaseURL: "https://urban-app-be1f9-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "urban-app-be1f9",
    appId: "1:297008657169:web:e9a9aadf8332b71a6392b0"
  };
  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  // sessions root + dynamic per-session paths (handles extra "some_name" level)
  let sessionsRoot = 'public/sessions';
  let sessionIndex = {}; // { sessionId: { label, readingsPath, metaPath, analysisPath } }

  // --- UI refs ---
  const sessionSel  = document.getElementById('sessionSel');
  const listenBtn   = document.getElementById('listenBtn');
  const stopBtn     = document.getElementById('stopBtn');
  const recenterBtn = document.getElementById('recenterBtn');
  const followChk   = document.getElementById('followChk');
  const accRange    = document.getElementById('accRange');
  const accVal      = document.getElementById('accVal');
  const statusEl    = document.getElementById('status');
  const shareBtn    = document.getElementById('shareBtn');

  const routeTableBody = document.getElementById('routeTableBody');

  const sCountEl    = document.getElementById('sCount');
  const comfortEl   = document.getElementById('comfort');
  const comfortBadge= document.getElementById('comfortBadge');
  const comfortBreak= document.getElementById('comfortBreak');
  const spdEl       = document.getElementById('spd');
  const amagEl      = document.getElementById('amag');
  const noiseEl     = document.getElementById('noise');
  const noiseHint   = document.getElementById('noiseHint');
  const tempEl      = document.getElementById('temp');
  const windEl      = document.getElementById('wind');
  const rainEl      = document.getElementById('rain');
  const lastPointEl = document.getElementById('lastPoint');
  const sessMetaEl  = document.getElementById('sessMeta');
  const sessAnalysisEl = document.getElementById('sessAnalysis');
  const skipAccEl   = document.getElementById('skipAcc');
  const skipBadEl   = document.getElementById('skipBad');
  const logEl       = document.getElementById('log');

  const tabs = document.querySelectorAll('.tab');
  const secMap   = document.getElementById('sec-map');
  const secCharts= document.getElementById('sec-charts');
  const secLog   = document.getElementById('sec-log');

  // weight sliders
  const wRoughInput = document.getElementById('wRough');
  const wNoiseInput = document.getElementById('wNoise');
  const wRainInput  = document.getElementById('wRain');
  const wWindInput  = document.getElementById('wWind');
  const wRoughVal   = document.getElementById('wRoughVal');
  const wNoiseVal   = document.getElementById('wNoiseVal');
  const wRainVal    = document.getElementById('wRainVal');
  const wWindVal    = document.getElementById('wWindVal');

  // tabs
  tabs.forEach(t=>t.addEventListener('click', ()=>{
    tabs.forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    const id=t.dataset.tab;
    [secMap,secCharts,secLog].forEach(s=>s.classList.remove('active'));
    ({map:secMap,charts:secCharts,log:secLog}[id]).classList.add('active');
    if (id==='map') setTimeout(()=>map.invalidateSize(), 50);
  }));

  const log = (msg, cls='')=>{
    const line=document.createElement('div');
    line.textContent=`[${new Date().toLocaleTimeString()}] ${msg}`;
    if(cls) line.className=cls;
    logEl.appendChild(line); logEl.scrollTop=logEl.scrollHeight;
    console.log('[viewer]', msg);
  };
  const num = v => (v===null||v===undefined||v==='') ? null : (Number.isFinite(+v)? +v : null);
  const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));

  // Map
  const map = L.map('map',{ zoomControl:true }).setView([53.3498,-6.2603],13);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    attribution:'Â© OpenStreetMap'
  }).addTo(map);
  let track=L.polyline([], {color:'#5bc0ff',weight:4,opacity:.95}).addTo(map);
  let marker=L.circleMarker([0,0], {radius:6,color:'#fff',weight:2,fillColor:'#1abc9c',fillOpacity:0.9}).addTo(map);
  let gotFirstFix=false, lastLatLng=null, AUTO_FOLLOW=true;
  let ACCURACY_MAX=parseInt(accRange.value,10);
  let skippedAcc=0, skippedBad=0;

  accRange.addEventListener('input',()=>{
    ACCURACY_MAX=parseInt(accRange.value,10);
    accVal.textContent=ACCURACY_MAX;
  });
  followChk.addEventListener('change',()=>{ AUTO_FOLLOW=followChk.checked; });

  function goodCoord(r){
    const lat=num(r.lat), lon=num(r.lon);
    if(lat==null || lon==null || Math.abs(lat)>90 || Math.abs(lon)>180){
      skippedBad++; skipBadEl.textContent=String(skippedBad); return null;
    }
    const acc=num(r.accuracy_m);
    if(acc!=null && acc>ACCURACY_MAX){
      skippedAcc++; skipAccEl.textContent=String(skippedAcc); return null;
    }
    return [lat,lon];
  }

  // Charts
  const accelChart=new Chart(document.getElementById('chartAccel'),{
    type:'line',
    data:{labels:[],datasets:[{label:'|a| m/sÂ²',data:[],tension:.2,borderWidth:2,pointRadius:0}]},
    options:{animation:false,plugins:{legend:{display:false}},scales:{x:{display:false}}}
  });
  const noiseChart=new Chart(document.getElementById('chartNoise'),{
    type:'line',
    data:{labels:[],datasets:[{label:'dBFS',data:[],tension:.2,borderWidth:2,pointRadius:0}]},
    options:{animation:false,plugins:{legend:{display:false}},scales:{x:{display:false}}}
  });
  function pushChart(chart,label,val){
    if(val==null) return;
    const d=chart.data; d.labels.push(label); d.datasets[0].data.push(val);
    if(d.labels.length>800){ d.labels.shift(); d.datasets[0].data.shift(); }
    chart.update('none');
  }

  // Comfort weights (global) + retro recompute
  const weights = { rough:1.0, noise:1.0, rain:1.0, wind:1.0 };
  function syncWeights(){
    weights.rough = parseFloat(wRoughInput.value);
    weights.noise = parseFloat(wNoiseInput.value);
    weights.rain  = parseFloat(wRainInput.value);
    weights.wind  = parseFloat(wWindInput.value);
    wRoughVal.textContent = weights.rough.toFixed(1);
    wNoiseVal.textContent = weights.noise.toFixed(1);
    wRainVal.textContent  = weights.rain.toFixed(1);
    wWindVal.textContent  = weights.wind.toFixed(1);

    // retroactively recompute whole session when sliders change
    recomputeSessionSummary();
  }
  [wRoughInput,wNoiseInput,wRainInput,wWindInput].forEach(inp=>inp.addEventListener('input', syncWeights));
  syncWeights();

  // Rolling std helper (used live + in recompute)
  function rollStdPush(arr,val,win=20){
    if(val==null) return 0;
    arr.push(val); if(arr.length>win) arr.shift();
    const n=arr.length, mean=arr.reduce((a,b)=>a+b,0)/n;
    const v=arr.reduce((a,b)=>a+(b-mean)*(b-mean),0)/n;
    return Math.sqrt(v);
  }
  let lastAmagVals=[];   // live window (for immediate per-row comfort display)

  // Comfort scoring
  function comfortParts(aStd,dbfs,precip,wind){
    const pRoughBase = clamp((aStd || 0) * 12, 0, 40);
    const baseDb     = (dbfs != null ? dbfs : -50);
    const pNoiseBase = clamp((baseDb + 60) * 0.8, 0, 25);
    const pRainBase  = clamp((precip || 0) * 10, 0, 20);
    const pWindBase  = clamp((wind   || 0) * 2, 0, 15);

    const pRough = pRoughBase * weights.rough;
    const pNoise = pNoiseBase * weights.noise;
    const pRain  = pRainBase  * weights.rain;
    const pWind  = pWindBase  * weights.wind;

    const score = clamp(Math.round(100-pRough-pNoise-pRain-pWind),0,100);
    return {score,pRough,pNoise,pRain,pWind};
  }

  function updateComfortUI(parts){
    comfortEl.textContent=parts.score;
    comfortBadge.textContent = parts.score>=70?'Good':parts.score>=50?'OK':'Low';
    comfortBadge.className='badge ' + (parts.score>=70?'ok':parts.score>=50?'warn':'err');
    comfortBreak.textContent=`penalties: rough ${parts.pRough.toFixed(1)}, noise ${parts.pNoise.toFixed(1)}, rain ${parts.pRain.toFixed(1)}, wind ${parts.pWind.toFixed(1)}`;
  }

  // Stats / summary + retro cache
  let currentSessionId=null;
  let stats=null;
  let lastSummaryWrite=0;
  const SUMMARY_MIN_INTERVAL=5000; // ms
  let sessionRows=[];              // cache of all readings for current session

  async function writeSummary(){
    if (!currentSessionId || !stats) return;
    const info = sessionIndex[currentSessionId];
    if (!info) return;

    const avgComfort = stats.n ? (stats.sumComfort / stats.n) : null;
    const pGood = stats.n ? (stats.nGood*100/stats.n).toFixed(1) : '0.0';
    const pOk   = stats.n ? (stats.nOk*100/stats.n).toFixed(1)   : '0.0';
    const pLow  = stats.n ? (stats.nLow*100/stats.n).toFixed(1)  : '0.0';

    const doc = {
      n: stats.n,
      avgComfort: avgComfort,
      nGood: stats.nGood,
      nOk: stats.nOk,
      nLow: stats.nLow,
      maxRoughPenalty: stats.maxRoughPenalty,
      maxNoisePenalty: stats.maxNoisePenalty,
      maxRainPenalty: stats.maxRainPenalty,
      maxWindPenalty: stats.maxWindPenalty,
      firstTs: stats.firstTs,
      lastTs: stats.lastTs,
      weights: {...weights},
      updatedAt: Date.now()
    };
    try{
      await set(ref(db, info.analysisPath), doc);
    }catch(e){
      log('summary write error: '+e.message,'err');
    }

    sessAnalysisEl.textContent = avgComfort!=null
      ? `avg ${avgComfort.toFixed(1)} Â· good ${pGood}% Â· ok ${pOk}% Â· low ${pLow}%`
      : 'â€”';
  }

  // Retroactive recompute
  function recomputeSessionSummary(){
    if (!currentSessionId || !sessionRows.length){
      stats = null;
      sessAnalysisEl.textContent = 'â€”';
      return;
    }

    stats = {
      n:0, sumComfort:0,
      nGood:0, nOk:0, nLow:0,
      maxRoughPenalty:0,
      maxNoisePenalty:0,
      maxRainPenalty:0,
      maxWindPenalty:0,
      firstTs:null,
      lastTs:null
    };

    const win=[]; // local accel window for std
    let lastParts=null;

    for (const r of sessionRows){
      const aTot = num(r.a_total);
      const aStd = rollStdPush(win,aTot,20);
      const db   = num(r.db_smooth!=null ? r.db_smooth : r.dbfs);
      const precip = num(r.w_precip_mm);
      const wind   = num(r.w_wind_mps);

      const parts = comfortParts(aStd, db, precip, wind);
      lastParts = parts;

      stats.n++;
      stats.sumComfort += parts.score;
      if (parts.score>=70) stats.nGood++;
      else if (parts.score>=50) stats.nOk++;
      else stats.nLow++;

      stats.maxRoughPenalty = Math.max(stats.maxRoughPenalty, parts.pRough);
      stats.maxNoisePenalty = Math.max(stats.maxNoisePenalty, parts.pNoise);
      stats.maxRainPenalty  = Math.max(stats.maxRainPenalty,  parts.pRain);
      stats.maxWindPenalty  = Math.max(stats.maxWindPenalty,  parts.pWind);

      const t = r.timestamp_ms ? +r.timestamp_ms : Date.now();
      if (stats.firstTs == null) stats.firstTs = t;
      stats.lastTs = t;
    }

    if (lastParts){
      updateComfortUI(lastParts);
    }

    const avgComfort = stats.n ? (stats.sumComfort / stats.n) : null;
    const pGood = stats.n ? (stats.nGood*100/stats.n).toFixed(1) : '0.0';
    const pOk   = stats.n ? (stats.nOk*100/stats.n).toFixed(1)   : '0.0';
    const pLow  = stats.n ? (stats.nLow*100/stats.n).toFixed(1)  : '0.0';
    sessAnalysisEl.textContent = avgComfort!=null
      ? `avg ${avgComfort.toFixed(1)} Â· good ${pGood}% Â· ok ${pOk}% Â· low ${pLow}%`
      : 'â€”';

    const now = Date.now();
    if (now - lastSummaryWrite > SUMMARY_MIN_INTERVAL){
      lastSummaryWrite = now;
      writeSummary();
    }
  }

  // Feed each reading row (live)
  function feedRow(r){
    // cache for retro recompute
    sessionRows.push(r);

    const aTot=num(r.a_total), db=num(r.db_smooth!=null?r.db_smooth:r.dbfs);
    const spd=num(r.speed_mps), tC=num(r.w_temp_c), wMps=num(r.w_wind_mps), rain=num(r.w_precip_mm);

    if(spd!=null) spdEl.textContent=spd.toFixed(2);
    if(aTot!=null) amagEl.textContent=aTot.toFixed(2);
    if(db!=null){ noiseEl.textContent=db.toFixed(1); noiseHint.textContent=''; }
    else { noiseEl.textContent='â€”'; noiseHint.textContent='No mic data in this session'; }
    if(tC!=null) tempEl.textContent=tC.toFixed(1);
    if(wMps!=null) windEl.textContent=wMps.toFixed(1);
    if(rain!=null) rainEl.textContent=rain.toFixed(2);

    // live comfort (uses its own rolling window)
    const std=rollStdPush(lastAmagVals,aTot,20);
    const parts=comfortParts(std,db,rain,wMps);
    updateComfortUI(parts);

    const latlng=goodCoord(r);
    if(latlng){
      lastLatLng=latlng; track.addLatLng(latlng); marker.setLatLng(latlng);
      const col = parts.score>=70 ? '#1abc9c' : parts.score>=50 ? '#f1c40f' : '#e74c3c';
      marker.setStyle({fillColor:col, color:'#fff'});

      if(!gotFirstFix){
        gotFirstFix=true;
        map.setView(latlng,16);
        recenterBtn.disabled=false;
        log(`map centered @ ${latlng[0].toFixed(5)}, ${latlng[1].toFixed(5)}`,'ok');
      } else if(AUTO_FOLLOW){
        map.panTo(latlng,{animate:false});
      }
      lastPointEl.textContent=`${latlng[0].toFixed(5)}, ${latlng[1].toFixed(5)} (accâ‰¤${ACCURACY_MAX}m)`;
    }else{
      const lat=r.lat ?? 'null', lon=r.lon ?? 'null', acc=r.accuracy_m ?? 'null';
      log(`skip row: lat=${lat} lon=${lon} acc=${acc}`,'warn');
    }

    const lbl=r.timestamp_ms? new Date(+r.timestamp_ms).toLocaleTimeString():'';
    pushChart(accelChart,lbl,aTot);
    pushChart(noiseChart,lbl,db);
    sCountEl.textContent=String((+sCountEl.textContent||0)+1);

    // recompute whole session stats with new row + current weights
    recomputeSessionSummary();
  }

  // Firebase listening
  let detach=null;

  // Try to find sessions root + handle "some_name" level
  async function loadSessions(){
    sessionSel.innerHTML='';
    routeTableBody.innerHTML='<tr><td colspan="4" style="padding:4px 6px;color:var(--mut);">Loadingâ€¦</td></tr>';
    statusEl.textContent='Loading sessionsâ€¦';
    log('Loading sessions (trying /public/sessions then /sessions)');

    sessionIndex = {};

    try{
      let usedRoot = null;
      let snap = await get(ref(db, 'public/sessions'));
      if (snap.exists()) {
        usedRoot = 'public/sessions';
      } else {
        log('No data under /public/sessions, trying /sessionsâ€¦','warn');
        const altSnap = await get(ref(db, 'sessions'));
        if (altSnap.exists()) {
          snap = altSnap;
          usedRoot = 'sessions';
        }
      }

      if (!usedRoot) {
        statusEl.textContent='No sessions found (checked /public/sessions and /sessions)';
        log('No sessions at /public/sessions or /sessions. Check Firebase paths.', 'err');
        routeTableBody.innerHTML='<tr><td colspan="4" style="padding:4px 6px;color:var(--mut);">No routes found yet. Record a walk with the logger.</td></tr>';
        return;
      }

      sessionsRoot = usedRoot;
      log(`Using sessions root: /${sessionsRoot}`, 'ok');

      const rootVal = snap.val() || {};
      const sessions=[];

      for (const [sessionId, val] of Object.entries(rootVal)) {
        const node = val || {};

        // Detect baseNode: either directly has readings, or one child has readings
        let baseKey = null;
        let baseNode = node;
        if (!node.readings || typeof node.readings !== 'object') {
          for (const [k, childNode] of Object.entries(node)) {
            if (childNode && typeof childNode === 'object' && childNode.readings) {
              baseKey = k;
              baseNode = childNode;
              break;
            }
          }
        }

        const meta = baseNode.meta || node.meta || {};
        const analysis = baseNode.analysis || node.analysis || null;
        const started = meta.startedAt || meta.startTime || 0;

        const basePath = baseKey
          ? `${sessionsRoot}/${sessionId}/${baseKey}`
          : `${sessionsRoot}/${sessionId}`;

        const readingsPath = `${basePath}/readings`;
        const metaPath = `${basePath}/meta`;
        const analysisPath = `${basePath}/analysis`;

        const label = meta.routeLabel
          || (started ? `Walk ${new Date(started).toISOString().replace('T',' ').slice(0,16)}` : sessionId);

        sessionIndex[sessionId] = { label, readingsPath, metaPath, analysisPath };

        sessions.push({id:sessionId, started, meta, analysis});
      }

      sessions.sort((a,b)=>b.started-a.started);
      log(`Found ${sessions.length} sessions under /${sessionsRoot}.`,'ok');

      // Dropdown options
      sessions.forEach((s,i)=>{
        const opt=document.createElement('option');
        const dt=s.started? new Date(s.started).toISOString().replace('T',' ').slice(0,19):'unknown';
        const label = sessionIndex[s.id]?.label || `Walk ${dt}`;
        if (s.analysis && typeof s.analysis.avgComfort==='number'){
          opt.textContent = `${label} â€” avg ${s.analysis.avgComfort.toFixed(1)} Â· ${dt}`;
        } else {
          opt.textContent = `${label} Â· ${dt}`;
        }
        opt.value=s.id;
        if(i===0) opt.selected=true;
        sessionSel.appendChild(opt);
      });

      if(sessions.length){
        sessMetaEl.textContent=JSON.stringify(sessions[0].meta||{},null,0);
        statusEl.textContent='Pick a session and tap Listen';
      }

      // Route comparison table
      routeTableBody.innerHTML='';
      if(!sessions.length){
        const tr=document.createElement('tr');
        tr.innerHTML='<td colspan="4" style="padding:4px 6px;color:var(--mut);">No routes found yet. Record a walk with the logger.</td>';
        routeTableBody.appendChild(tr);
      }else{
        const summaries = sessions.map(s=>{
          const a=s.analysis;
          const n=a?.n ?? null;
          const avg=(a && typeof a.avgComfort==='number') ? a.avgComfort : null;
          const nGood=a?.nGood ?? 0;
          const nOk=a?.nOk ?? 0;
          const nLow=a?.nLow ?? 0;
          const label=sessionIndex[s.id]?.label || (s.started? `Walk ${new Date(s.started).toISOString().replace('T',' ').slice(0,16)}` : s.id);
          return {id:s.id,label,started:s.started,avg,n,nGood,nOk,nLow};
        });

        // sort by avg comfort desc, then newest
        summaries.sort((a,b)=>{
          if(a.avg==null && b.avg==null) return b.started-a.started;
          if(a.avg==null) return 1;
          if(b.avg==null) return -1;
          return b.avg-a.avg;
        });

        summaries.forEach(sum=>{
          const tr=document.createElement('tr');
          tr.className='clickable';
          tr.addEventListener('click',()=>{
            sessionSel.value=sum.id;
            listenSession(sum.id);
            window.scrollTo({top:0,behavior:'smooth'});
          });

          const tdRoute=document.createElement('td');
          tdRoute.textContent=sum.label;

          const tdAvg=document.createElement('td');
          tdAvg.className='num';
          if(sum.avg==null){
            tdAvg.textContent='â€”';
            tdAvg.classList.add('hint');
          }else{
            tdAvg.textContent=sum.avg.toFixed(1);
            tdAvg.classList.add(sum.avg>=70?'ok':sum.avg>=50?'warn':'err');
          }

          const tdDist=document.createElement('td');
          tdDist.className='num';
          if(sum.n && sum.avg!=null){
            const pG=(sum.nGood*100/sum.n).toFixed(0);
            const pO=(sum.nOk*100/sum.n).toFixed(0);
            const pL=(sum.nLow*100/sum.n).toFixed(0);
            tdDist.textContent=`${pG}% / ${pO}% / ${pL}%`;
          }else{
            tdDist.textContent='â€”';
            tdDist.classList.add('hint');
          }

          const tdN=document.createElement('td');
          tdN.className='num';
          tdN.textContent = sum.n!=null ? String(sum.n) : 'â€”';

          tr.appendChild(tdRoute);
          tr.appendChild(tdAvg);
          tr.appendChild(tdDist);
          tr.appendChild(tdN);
          routeTableBody.appendChild(tr);
        });
      }
    }catch(e){
      statusEl.textContent='Error loading sessions';
      log('Error loading sessions: '+e.message,'err');
      log('If message is PERMISSION_DENIED, check Firebase rules for .read on sessions root.','err');
    }
  }

  async function listenSession(sessionId){
    const info = sessionIndex[sessionId];
    if (!info) {
      log(`No path info found for session ${sessionId}. Check viewer vs logger structure.`, 'err');
      return;
    }

    if(detach){ detach(); detach=null; }
    currentSessionId = sessionId;

    track.remove(); marker.remove();
    track=L.polyline([], {color:'#5bc0ff',weight:4,opacity:.95}).addTo(map);
    marker=L.circleMarker([0,0], {radius:6,color:'#fff',weight:2,fillColor:'#1abc9c',fillOpacity:0.9}).addTo(map);
    gotFirstFix=false; lastLatLng=null; skippedAcc=0; skippedBad=0;
    skipAccEl.textContent='0'; skipBadEl.textContent='0';
    sCountEl.textContent='0';
    comfortEl.textContent='â€”'; comfortBadge.textContent='â€”'; comfortBadge.className='badge';
    lastAmagVals.length=0; sessAnalysisEl.textContent='â€”';
    recenterBtn.disabled=true;

    // reset stats + retro cache
    stats = {
      n:0, sumComfort:0,
      nGood:0, nOk:0, nLow:0,
      maxRoughPenalty:0,
      maxNoisePenalty:0,
      maxRainPenalty:0,
      maxWindPenalty:0,
      firstTs:null,
      lastTs:null
    };
    lastSummaryWrite=0;
    sessionRows = [];

    const path=info.readingsPath;
    const readingsRef = ref(db, path);
    const handler=snap=>feedRow(snap.val());
    onChildAdded(readingsRef,handler);
    detach=()=> off(readingsRef,'child_added',handler);

    statusEl.textContent=`Listening: ${sessionId} (${path})`;
    stopBtn.disabled=false; listenBtn.disabled=true; sessionSel.disabled=true;
    setTimeout(()=>map.invalidateSize(),120);
    log(`Listening to ${path}`,'ok');

    try{
      const metaSnap=await get(ref(db, info.metaPath));
      if(metaSnap.exists()) sessMetaEl.textContent=JSON.stringify(metaSnap.val(),null,0);
    }catch(e){
      log('meta load error: '+e.message,'err');
    }

    try{
      const anaSnap=await get(ref(db, info.analysisPath));
      if(anaSnap.exists()){
        const a=anaSnap.val();
        const n=a.n||0, avg=a.avgComfort!=null ? a.avgComfort : null;
        const pGood=n ? (a.nGood*100/n).toFixed(1) : '0.0';
        const pOk  =n ? (a.nOk*100/n).toFixed(1)   : '0.0';
        const pLow =n ? (a.nLow*100/n).toFixed(1)  : '0.0';
        if(avg!=null){
          sessAnalysisEl.textContent=`avg ${avg.toFixed(1)} Â· good ${pGood}% Â· ok ${pOk}% Â· low ${pLow}%`;
        }
      }
    }catch(e){
      log('analysis load error: '+e.message,'err');
    }
  }

  function stopListening(){
    if(detach){ detach(); detach=null; log('Stopped listening','warn'); }
    stopBtn.disabled=true; listenBtn.disabled=false; sessionSel.disabled=false;
    statusEl.textContent='';
  }

  // share link
  shareBtn.addEventListener('click',async()=>{
    const sid=sessionSel.value;
    if(!sid){ log('No session selected','warn'); return; }
    const url=`${location.origin}${location.pathname}?session=${encodeURIComponent(sid)}`;
    try{ await navigator.clipboard.writeText(url); log('Share link copied: '+url,'ok'); }
    catch(e){ log('Copy failed; URL: '+url,'warn'); alert(url); }
  });

  listenBtn.addEventListener('click',()=> listenSession(sessionSel.value));
  stopBtn.addEventListener('click',stopListening);
  recenterBtn.addEventListener('click',()=>{ if(lastLatLng){ map.setView(lastLatLng,16); map.invalidateSize(); }});

  accVal.textContent=accRange.value;
  loadSessions();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Calm Strider â€” Logger</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; background:#0b1320; color:#e9eef6; }
    header { padding: 16px 20px; background: #111a2e; box-shadow: 0 2px 10px rgba(0,0,0,.2); position: sticky; top: 0; z-index: 10; }
    h1 { margin: 0; font-size: 18px; letter-spacing:.3px; }
    main { padding: 20px; max-width: 980px; margin: 0 auto; }
    .card { background:#121a33; border:1px solid #1f2a4a; border-radius: 16px; padding: 16px; margin-bottom: 16px; box-shadow: 0 6px 24px rgba(0,0,0,.25); }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items: center; }
    button, select, input[type="number"], input[type="text"] {
      appearance:none; border:1px solid #2b3c67; background:#1a2550; color:#e9eef6;
      padding: 10px 14px; border-radius: 12px; font-weight:600; font-size: 13px;
    }
    button { cursor:pointer; }
    button[disabled] { opacity:.6; cursor:not-allowed; }
    .stat { min-width: 140px; background:#0f1730; border:1px solid #1f2a4a; padding:10px 12px; border-radius:12px; text-align:left; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 12px; opacity:.8; }
    .log { max-height: 260px; overflow: auto; background:#0f1730; border:1px solid #1f2a4a; padding:10px; border-radius: 12px; }
    .ok { color:#6df0a8 }
    .warn { color:#ffd580 }
    .err { color:#ff8797 }
    label.l { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2b3c67; border-radius:10px; background:#0f1730; }
    .pill { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid #2b3c67; background:#0f1730; font-size:12px; }
    input.route { flex:1 1 220px; }
  </style>
</head>

<!-- Firebase + batch uploader (with anonymous Auth) -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
  import { getDatabase, ref, push, update, set } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-database.js";
  import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB0yzdcWJxsO3dtqWlTJyEjupV8_mdzm0E",
    authDomain: "urban-app-be1f9.firebaseapp.com",
    databaseURL: "https://urban-app-be1f9-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "urban-app-be1f9",
    appId: "1:297008657169:web:e9a9aadf8332b71a6392b0"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);
  const auth = getAuth(app);

  let authUid = null;

  async function ensureAuth() {
    if (authUid) return authUid;
    const cred = await signInAnonymously(auth);
    authUid = cred.user.uid;
    console.log('[logger] signed in as', authUid);
    if (window.log) {
      window.log(`[auth] signed in (uid=${authUid.slice(0,8)}â€¦)`, 'ok');
    }
    return authUid;
  }

  // Kick off auth once (donâ€™t block UI)
  ensureAuth().catch(e => {
    console.error('[logger auth] initial sign-in failed:', e);
    window.log?.(`[auth] error: ${e.message}`, 'err');
  });

  // --- Tiny batch uploader to /public/sessions/{sessionId}/readings ---
  let sessionId = null;
  let buffer = [];
  let flushTimer = null;
  const BUFFER_MAX = 50;
  const FLUSH_MS = 1000;

  async function flushBuffer() {
    if (!sessionId || buffer.length === 0) return;
    const updates = {};
    for (const row of buffer) {
      const key = push(ref(db, `public/sessions/${sessionId}/readings`)).key;
      updates[`public/sessions/${sessionId}/readings/${key}`] = row;
    }
    const count = buffer.length;
    buffer = [];
    try {
      await update(ref(db), updates);
      console.log(`[cloud] uploaded ${count} row(s) â†’ public/sessions/${sessionId}`);
      window.log?.(`[cloud] uploaded ${count} row(s)`, 'ok');
    } catch (e) {
      console.error('[cloud] upload error:', e);
      window.log?.(`[cloud] upload error: ${e.message}`, 'err');
    }
  }

  async function startSession(meta) {
    sessionId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Date.now());

    let ownerUid = null;
    try {
      ownerUid = await ensureAuth();
    } catch (e) {
      console.error('[logger auth] startSession auth failed:', e);
      ownerUid = null;
    }

    const fullMeta = {
      ...meta,
      ownerUid: ownerUid || null,
      startedAt: Date.now(),
      sdk: "web-rtdb-anon-auth"
    };

    set(ref(db, `public/sessions/${sessionId}/meta`), fullMeta).catch((e)=>{
      console.error('[cloud] meta write error', e);
      window.log?.(`[cloud] meta write error: ${e.message}`, 'err');
    });

    if (flushTimer) clearInterval(flushTimer);
    flushTimer = setInterval(flushBuffer, FLUSH_MS);
    window.log?.(`[cloud] session: public/sessions/${sessionId}`, 'ok');
  }

  function stopSession(){
    if (flushTimer) clearInterval(flushTimer), flushTimer = null;
    flushBuffer();
  }

  function onSample(row){
    buffer.push(row);
    if (buffer.length >= BUFFER_MAX) flushBuffer();
  }

  // Optional: open data branch (/open/weather/â€¦), not strictly needed for viewer
  function tile(lat, lon, step=0.01){
    const r=v => (Math.round(v/step)*step).toFixed(2);
    return `${r(lat)}_${r(lon)}`;
  }
  async function writeWeather(lat, lon, snap){
    try {
      const t = Date.now();
      const til = tile(lat, lon);
      await set(ref(db, `open/weather/${til}/${t}`), {
        lat, lon, ...snap, fetched_at: t, source: "open-meteo"
      });
    } catch(e){
      console.error("[cloud] weather write error", e);
      window.log?.(`[cloud] weather write error: ${e.message}`, 'err');
    }
  }

  window.firebaseUpload = { startSession, onSample, stopSession, writeWeather };
</script>

<body>
  <header>
    <h1>ðŸ“± Calm Strider â€” Logger</h1>
  </header>
  <main>
    <div class="card">
      <p>Record accelerometer, GPS and optional microphone <em>loudness</em> (no audio saved). Exports a CSV locally and uploads readings to Firebase.</p>
      <p class="small">
        Columns: timestamp_iso, timestamp_ms, lat, lon, accuracy_m, altitude_m, speed_mps, heading_deg,
        ax, ay, az, a_total, rot_alpha_dps, rot_beta_dps, rot_gamma_dps, dbfs, db_smooth, mic_active, tag, w_temp_c, w_wind_mps, w_precip_mm, sample_id
      </p>
    </div>

    <div class="card">
      <div class="row" style="gap:8px; margin-bottom:12px;">
        <button id="permBtn">Request Permissions</button>
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="downloadBtn" disabled>Download CSV</button>
        <button id="startMicBtn">Start Mic</button>
        <button id="stopMicBtn" disabled>Stop Mic</button>
        <button id="tagBtn">Tag</button>
      </div>
      <div class="row" style="gap:8px; margin-bottom:10px;">
        <span class="pill">
          Route label:
          <input id="routeInput" class="route" type="text" placeholder="e.g. Home â†’ Campus" />
        </span>
        <label class="l small">Mode
          <select id="modeSel" class="mono">
            <option value="throttle" selected>Event-throttle</option>
            <option value="timer">Fixed-interval</option>
          </select>
        </label>
        <label class="l small">Rate
          <select id="rateSel" class="mono">
            <option value="0.5">0.5 Hz</option>
            <option value="1">1 Hz</option>
            <option value="2">2 Hz</option>
            <option value="5">5 Hz</option>
            <option value="10">10 Hz</option>
            <option value="20" selected>20 Hz</option>
            <option value="50">50 Hz</option>
            <option value="60">60 Hz</option>
            <option value="raw">raw</option>
          </select>
        </label>
      </div>
      <div class="row">
        <div class="stat"><div class="small">Samples</div><div class="mono" id="samples">0</div></div>
        <div class="stat"><div class="small">GPS Fix</div><div class="mono" id="gps">â€”</div></div>
        <div class="stat"><div class="small">Speed (m/s)</div><div class="mono" id="speed">â€”</div></div>
        <div class="stat"><div class="small">Accel |a| (m/sÂ²)</div><div class="mono" id="amag">â€”</div></div>
        <div class="stat"><div class="small">Noise (dBFS)</div><div class="mono" id="db">â€”</div></div>
        <div class="stat"><div class="small">Mic</div><div class="mono" id="mic">off</div></div>
        <div class="stat"><div class="small">Tags</div><div class="mono" id="tags">0</div></div>
      </div>
    </div>

    <div class="card">
      <div class="small">Status</div>
      <pre class="log mono" id="log"></pre>
    </div>
  </main>

<script>
(function(){
  const permBtn = document.getElementById('permBtn');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const samplesEl = document.getElementById('samples');
  const gpsEl = document.getElementById('gps');
  const speedEl = document.getElementById('speed');
  const amagEl = document.getElementById('amag');
  const dbEl = document.getElementById('db');
  const micEl = document.getElementById('mic');
  const tagsEl = document.getElementById('tags');
  const logEl = document.getElementById('log');
  const rateSel = document.getElementById('rateSel');
  const modeSel = document.getElementById('modeSel');
  const routeInput = document.getElementById('routeInput');

  let recording = false;
  let watchId = null;
  let latestGeo = null;
  let data = [];
  let sampleId = 0;

  // motion snapshot (used by timer mode)
  let lastAx = null, lastAy = null, lastAz = null, lastAmag = null;
  let motionHandler = null;

  // Audio (mic) state
  let audioCtx = null, analyser = null, micStream = null, micRaf = null;
  let micActive = false;
  let lastDbfs = null, lastDbSmooth = null;

  // Weather snapshot (for fusion columns)
  let lastWeather = null; // { temp_c, wind_mps, precip_mm }
  let lastWeatherFetch = 0;
  const WEATHER_MIN_MS = 60000; // 60s

  // Tagging
  let tags = [];
  let lastTag = null; // attached to next sample then cleared

  // Sampling control
  let writeMode = 'throttle'; // 'throttle' | 'timer'
  let minIntervalMs = 50;     // throttle interval (derived from rate)
  let timerId = null;         // setInterval id for timer mode
  let intervalMs = 50;        // timer interval (derived from rate)
  let lastWriteTs = 0;        // last time we wrote a row (throttle)

  // Route label memory
  const ROUTE_KEY = 'calmStriderRouteLabel';
  const savedRoute = localStorage.getItem(ROUTE_KEY);
  if (savedRoute) routeInput.value = savedRoute;

  window.log = (msg, cls='') => {
    const line = document.createElement('div');
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    if (cls) line.className = cls;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  };

  function hasMotionSupport(){ return 'DeviceMotionEvent' in window; }
  function hasGeoSupport(){ return 'geolocation' in navigator; }

  async function requestPermissions(){
    try {
      if (!hasMotionSupport()) {
        log('DeviceMotion not supported on this device.', 'err');
      } else if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const resp = await DeviceMotionEvent.requestPermission();
        log(`Motion permission: ${resp}`, resp === 'granted' ? 'ok' : 'err');
      } else {
        log('Motion permission: not required on this device', 'ok');
      }

      if (hasGeoSupport()) {
        await new Promise((resolve) => {
          navigator.geolocation.getCurrentPosition(
            (pos) => { latestGeo = pos; log('Location permission granted', 'ok'); resolve(); },
            (err) => { log('Location permission error: ' + err.message, 'err'); resolve(); },
            { enableHighAccuracy: true, timeout: 7000, maximumAge: 0 }
          );
        });
      } else {
        log('Geolocation not supported on this device.', 'err');
      }
    } catch (e) {
      log('Permission request error: ' + e.message, 'err');
    }
  }

  // Fetch weather & optionally write to /open/weather
  async function fetchWeather(lat, lon){
    try{
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,wind_speed_10m,precipitation`;
      const j = await fetch(url).then(r=>r.json());
      const cur = j.current || j.current_weather || {};
      lastWeather = {
        temp_c: typeof cur.temperature_2m === 'number' ? cur.temperature_2m :
                typeof cur.temperature === 'number' ? cur.temperature : null,
        wind_mps: typeof cur.wind_speed_10m === 'number' ? cur.wind_speed_10m : null,
        precip_mm: typeof cur.precipitation === 'number' ? cur.precipitation : null
      };
      lastWeatherFetch = Date.now();
      log(`Weather updated: T=${lastWeather.temp_c}Â°C, wind=${lastWeather.wind_mps}m/s, rain=${lastWeather.precip_mm}mm/h`, 'ok');

      if (window.firebaseUpload && window.firebaseUpload.writeWeather){
        window.firebaseUpload.writeWeather(lat, lon, lastWeather);
      }
    }catch(e){
      console.error('weather fetch error', e);
      log('Weather fetch error: ' + e.message, 'warn');
    }
  }

  // --- CSV builder (tested) ---
  function buildCSV(headers, rows){
    const esc = (v) => {
      if (v == null) return '';
      const s = String(v);
      const needsQuotes = /[",\n\r]/.test(s);
      const q = s.replace(/"/g, '""');
      return needsQuotes ? '"' + q + '"' : q;
    };
    let out = headers.join(',') + '\n';
    for (const row of rows){ out += headers.map(h => esc(row[h])).join(',') + '\n'; }
    return out;
  }

  function makeRow(now){
    const g = latestGeo ? latestGeo.coords : {};
    const r = { alpha: null, beta: null, gamma: null }; // rotation rate placeholder

    const w = lastWeather || {};
    return {
      timestamp_iso: new Date(now).toISOString(),
      timestamp_ms: now,
      lat: g.latitude ?? null,
      lon: g.longitude ?? null,
      accuracy_m: g.accuracy ?? null,
      altitude_m: g.altitude ?? null,
      speed_mps: g.speed ?? null,
      heading_deg: g.heading ?? null,
      ax: lastAx, ay: lastAy, az: lastAz,
      a_total: lastAmag,
      rot_alpha_dps: r.alpha ?? null,
      rot_beta_dps: r.beta ?? null,
      rot_gamma_dps: r.gamma ?? null,
      dbfs: lastDbfs,
      db_smooth: lastDbSmooth,
      mic_active: micActive ? 1 : 0,
      tag: lastTag,
      w_temp_c: w.temp_c ?? null,
      w_wind_mps: w.wind_mps ?? null,
      w_precip_mm: w.precip_mm ?? null,
      sample_id: sampleId++
    };
  }

  function pushRow(now){
    const row = makeRow(now);
    data.push(row);
    samplesEl.textContent = String(data.length);
    if (lastTag) lastTag = null; // consume

    if (window.firebaseUpload && window.firebaseUpload.onSample){
      window.firebaseUpload.onSample(row);
    }
  }

  async function start(){
    if (recording) return;
    data = [];
    sampleId = 0;
    lastWriteTs = 0;
    recording = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    downloadBtn.disabled = true;
    log('Recording started', 'ok');

    // route label
    let label = routeInput.value.trim();
    if (!label) {
      label = prompt('Route label (e.g., Home â†’ Campus)') || '';
      label = label.trim();
      routeInput.value = label;
    }
    if (!label) label = 'Untitled route';
    localStorage.setItem(ROUTE_KEY, label);

    // start Firebase session
    if (window.firebaseUpload && window.firebaseUpload.startSession){
      const meta = {
        routeLabel: label,
        mode: writeMode,
        rateHz: rateSel.value === 'raw' ? 'raw' : parseFloat(rateSel.value),
        userAgent: navigator.userAgent
      };
      window.firebaseUpload.startSession(meta).catch?.(e=>{
        console.error('startSession error', e);
        log('Cloud session error: ' + e.message, 'err');
      });
    }

    // GPS
    if (hasGeoSupport()) {
      watchId = navigator.geolocation.watchPosition((pos) => {
        latestGeo = pos;
        const s = pos.coords.speed; // m/s (may be null)
        gpsEl.textContent = `${pos.coords.latitude?.toFixed?.(5) ?? 'â€”'}, ${pos.coords.longitude?.toFixed?.(5) ?? 'â€”'} Â±${(pos.coords.accuracy||0).toFixed(0)}m`;
        speedEl.textContent = (s!=null? s.toFixed(2): 'â€”');

        const now = Date.now();
        if (now - lastWeatherFetch > WEATHER_MIN_MS &&
            typeof pos.coords.latitude === 'number' &&
            typeof pos.coords.longitude === 'number') {
          fetchWeather(pos.coords.latitude, pos.coords.longitude);
        }
      }, (err) => {
        log('GPS error: ' + err.message, 'warn');
      }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 });
    }

    // Motion
    motionHandler = (ev) => {
      const aIncG = ev.accelerationIncludingGravity || ev.acceleration || {};
      lastAx = aIncG.x ?? null; lastAy = aIncG.y ?? null; lastAz = aIncG.z ?? null;
      lastAmag = (lastAx!=null && lastAy!=null && lastAz!=null) ? Math.sqrt(lastAx*lastAx + lastAy*lastAy + lastAz*lastAz) : null;
      amagEl.textContent = (lastAmag!=null) ? lastAmag.toFixed(2) : 'â€”';

      if (writeMode === 'throttle'){
        const now = Date.now();
        if (minIntervalMs && (now - lastWriteTs) < minIntervalMs) return;
        lastWriteTs = now;
        pushRow(now);
      }
    };
    window.addEventListener('devicemotion', motionHandler, { passive: true });

    // Timer mode
    if (writeMode === 'timer'){
      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => { pushRow(Date.now()); }, intervalMs);
      log(`Fixed-interval mode @ ${Math.round(1000/intervalMs)} Hz`, 'ok');
    }

    // Warn if no samples
    setTimeout(() => {
      if (recording && data.length === 0) log('No samples yet. On iOS, tap "Request Permissions" and move the phone slightly.', 'warn');
    }, 5000);
  }

  function stop(){
    if (!recording) return;
    recording = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    downloadBtn.disabled = data.length === 0;

    if (watchId != null) { navigator.geolocation.clearWatch(watchId); watchId = null; }
    if (motionHandler) { window.removeEventListener('devicemotion', motionHandler); motionHandler = null; }
    if (timerId) { clearInterval(timerId); timerId = null; }

    if (window.firebaseUpload && window.firebaseUpload.stopSession){
      window.firebaseUpload.stopSession();
    }

    log(`Recording stopped. ${data.length} samples captured.`, 'ok');
  }

  function downloadCSV(){
    if (!data.length) { log('Nothing to download', 'warn'); return; }
    const headers = [
      'timestamp_iso','timestamp_ms','lat','lon','accuracy_m','altitude_m','speed_mps','heading_deg',
      'ax','ay','az','a_total','rot_alpha_dps','rot_beta_dps','rot_gamma_dps',
      'dbfs','db_smooth','mic_active','tag','w_temp_c','w_wind_mps','w_precip_mm','sample_id'
    ];
    const csv = buildCSV(headers, data);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const ts = new Date().toISOString().replaceAll(':','-');
    a.download = `sensor_log_${ts}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
    log('CSV downloaded', 'ok');
  }

  // Mic helpers
  async function startMic(){
    try{
      if (micActive) return;
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        log('Mic not supported on this browser.', 'err'); return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      micStream = stream;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') await audioCtx.resume();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      const src = audioCtx.createMediaStreamSource(stream);
      src.connect(analyser);
      micActive = true;
      document.getElementById('startMicBtn').disabled = true;
      document.getElementById('stopMicBtn').disabled = false;
      micEl.textContent = 'on';

      const buf = new Float32Array(analyser.fftSize);
      const alpha = 0.2; // smoothing for dB
      const update = () => {
        if (!micActive) return;
        analyser.getFloatTimeDomainData(buf);
        let sum = 0; for (let i=0;i<buf.length;i++){ const v=buf[i]; sum += v*v; }
        const rms = Math.sqrt(sum / buf.length) + 1e-12;
        lastDbfs = 20 * Math.log10(rms);
        lastDbSmooth = (lastDbSmooth==null) ? lastDbfs : (alpha*lastDbfs + (1-alpha)*lastDbSmooth);
        dbEl.textContent = lastDbSmooth.toFixed(1);
        micRaf = requestAnimationFrame(update);
      };
      update();
      log('Mic started (dBFS, relative; no audio stored).', 'ok');
    }catch(e){ log('Mic error: ' + e.message, 'err'); }
  }
  function stopMic(){
    if (!micActive) return;
    micActive = false;
    if (micRaf) cancelAnimationFrame(micRaf), micRaf = null;
    if (micStream) { micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
    if (audioCtx) { audioCtx.close(); audioCtx=null; }
    analyser=null; lastDbfs=null; // keep lastDbSmooth visible
    document.getElementById('startMicBtn').disabled = false;
    document.getElementById('stopMicBtn').disabled = true;
    micEl.textContent = 'off';
    log('Mic stopped', 'ok');
  }

  // Tag helper
  function addTag(){
    const label = prompt('Tag label (e.g., obstruction, ramp, noise, note:...)');
    if (!label) return;
    tags.push({ ts: Date.now(), label });
    lastTag = label; // attach to next sample
    tagsEl.textContent = String(tags.length);
    log('Tagged: ' + label, 'ok');
  }

  // --- Self-tests (basic) ---
  function runSelfTests(){
    (function(){
      const H = ['a','b']; const R = [{a:1,b:2}];
      const csv = buildCSV(H,R); const lines = csv.split('\n');
      const ok = lines.length >= 2 && lines[0] === 'a,b' && lines[1].startsWith('1,2');
      log('[test] CSV newline construction', ok ? 'ok' : 'err');
    })();
    (function(){
      const H = ['x']; const R = [{x:'he said, "hi"'}];
      const csv = buildCSV(H,R); const ok = csv.includes('"he said, ""hi"""');
      log('[test] CSV quoting commas/quotes', ok ? 'ok' : 'err');
    })();
    (function(){
      const H = ['y']; const R = [{y:'line1\nline2'}];
      const csv = buildCSV(H,R); const ok = csv.includes('"line1\nline2"');
      log('[test] CSV quoting newlines', ok ? 'ok' : 'err');
    })();
  }

  // UI wiring
  permBtn.addEventListener('click', requestPermissions);
  startBtn.addEventListener('click', start);
  stopBtn.addEventListener('click', stop);
  downloadBtn.addEventListener('click', downloadCSV);
  document.getElementById('startMicBtn').addEventListener('click', startMic);
  document.getElementById('stopMicBtn').addEventListener('click', stopMic);
  document.getElementById('tagBtn').addEventListener('click', addTag);
  modeSel.addEventListener('change', () => {
    writeMode = modeSel.value; // 'throttle' | 'timer'
    const v = rateSel.value; // recompute intervals on mode switch
    applyRate(v);
    log(`Mode set to: ${writeMode}`, 'ok');
  });
  rateSel.addEventListener('change', () => applyRate(rateSel.value));

  function applyRate(v){
    if (v === 'raw'){
      minIntervalMs = 0; intervalMs = 0; log('Rate: raw (no throttle)', 'ok'); return;
    }
    const hz = parseFloat(v);
    const ms = Math.max(1, Math.round(1000 / hz));
    if (writeMode === 'throttle') {
      minIntervalMs = ms;
      log(`Throttle: ~${hz} Hz (${ms} ms)`, 'ok');
    } else {
      intervalMs = ms;
      if (timerId){
        clearInterval(timerId);
        timerId = setInterval(()=>{ if(recording) pushRow(Date.now()); }, intervalMs);
      }
      log(`Fixed-interval: ${hz} Hz (${ms} ms)`, 'ok');
    }
  }

  // Initial rate apply
  applyRate(rateSel.value);

  if (!hasMotionSupport()) log('This browser does not support DeviceMotion API. Try a modern mobile browser.', 'err');
  if (!hasGeoSupport()) log('Geolocation not available.', 'warn');

  runSelfTests();
})();
</script>
</body>
</html>
